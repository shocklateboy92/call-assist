#!/usr/bin/env node

import { createServer, createChannel, createClientFactory } from 'nice-grpc';
import { MatrixClient, createClient, MsgType, ClientEvent, RoomEvent } from 'matrix-js-sdk';
import { promises as fs } from 'fs';
import path from 'path';

// Import generated protobuf types (will be generated by ts-proto)
// These imports will be available after running the proto generation
// import { CallPluginServiceDefinition } from './proto_gen/call_plugin';
// import { CallRequest, CallResponse, CallState } from './proto_gen/common';

// Matrix plugin configuration interface
interface MatrixConfig {
  homeserver: string;
  accessToken: string;
  userId: string;
}

class MatrixCallPlugin {
  private matrixClient: MatrixClient | null = null;
  private server: any = null;
  private config: MatrixConfig | null = null;
  private activeWebRTCCalls: Map<string, any> = new Map();

  constructor() {
    console.log('Matrix Call Plugin initializing...');
  }

  async initialize(): Promise<void> {
    console.log('Starting Matrix Call Plugin...');
    
    // Start gRPC server to communicate with broker
    await this.startGrpcServer();
    
    console.log('Matrix Call Plugin started successfully');
  }

  private async startGrpcServer(): Promise<void> {
    // Note: This will use the generated protobuf types once they're available
    
    const server = createServer();
    
    // Implement CallPlugin service
    const callPluginService = {
      // Initialize plugin with credentials
      initialize: async (request: any) => {
        console.log('Received initialize request:', request);
        
        try {
          this.config = {
            homeserver: request.credentials.homeserver || 'https://matrix.org',
            accessToken: request.credentials.access_token,
            userId: request.credentials.user_id
          };
          
          // Initialize Matrix client
          await this.initializeMatrixClient();
          
          return {
            success: true,
            message: 'Matrix plugin initialized successfully'
          };
        } catch (error) {
          console.error('Matrix plugin initialization failed:', error);
          return {
            success: false,
            message: `Initialization failed: ${error}`
          };
        }
      },

      // Start a call
      startCall: async (request: any) => {
        console.log('Received start call request:', request);
        
        if (!this.matrixClient || !this.config) {
          return {
            success: false,
            message: 'Matrix client not initialized'
          };
        }

        try {
          // Parse Matrix room ID or user ID from target address
          const roomId = request.targetAddress;
          
          // For now, we'll create a simple room invitation
          // In a full implementation, this would handle WebRTC call setup
          const callId = `matrix_call_${Date.now()}`;
          
          // Send a message to the room indicating call attempt
          await this.matrixClient.sendMessage(roomId, {
            msgtype: MsgType.Text,
            body: `ðŸ“ž Incoming video call from ${this.config.userId} (Call ID: ${callId})`
          });
          
          // Store call information
          this.activeWebRTCCalls.set(callId, {
            roomId,
            startTime: Date.now(),
            state: 'calling'
          });
          
          return {
            success: true,
            callId: callId,
            message: 'Call initiated successfully'
          };
          
        } catch (error) {
          console.error('Failed to start Matrix call:', error);
          return {
            success: false,
            message: `Call failed: ${error}`
          };
        }
      },

      // End a call
      endCall: async (request: any) => {
        console.log('Received end call request:', request);
        
        const callId = request.callId;
        const callInfo = this.activeWebRTCCalls.get(callId);
        
        if (!callInfo) {
          return {
            success: false,
            message: 'Call not found'
          };
        }

        try {
          // Send end call message
          if (this.matrixClient) {
            await this.matrixClient.sendMessage(callInfo.roomId, {
              msgtype: MsgType.Text,
              body: `ðŸ“ž Call ended (Call ID: ${callId})`
            });
          }
          
          // Remove from active calls
          this.activeWebRTCCalls.delete(callId);
          
          return {
            success: true,
            message: 'Call ended successfully'
          };
          
        } catch (error) {
          console.error('Failed to end Matrix call:', error);
          return {
            success: false,
            message: `Failed to end call: ${error}`
          };
        }
      },

      // Get plugin capabilities
      getCapabilities: async (request: any) => {
        return {
          videoCodecs: ['VP8', 'VP9', 'H264'],
          audioCodecs: ['OPUS', 'G722'],
          maxResolution: '1080p',
          supportsWebRTC: true,
          supportedFeatures: ['video_call', 'audio_call', 'screen_share']
        };
      }
    };

    // Note: Once protobuf types are generated, we'll add the service properly
    // server.add(CallPluginServiceDefinition, callPluginService);
    
    await server.listen('0.0.0.0:50052');
    this.server = server;
    
    console.log('Matrix plugin gRPC server listening on port 50052');
  }

  private async initializeMatrixClient(): Promise<void> {
    if (!this.config) {
      throw new Error('Matrix configuration not provided');
    }

    console.log(`Initializing Matrix client for ${this.config.userId}`);
    
    this.matrixClient = createClient({
      baseUrl: this.config.homeserver,
      accessToken: this.config.accessToken,
      userId: this.config.userId
    });

    // Set up event handlers
    this.matrixClient.on(ClientEvent.Sync, (state) => {
      console.log(`Matrix sync state: ${state}`);
    });

    this.matrixClient.on(RoomEvent.Timeline, (event, room) => {
      // Handle incoming messages and call events
      if (event.getType() === 'm.call.invite') {
        console.log('Received incoming call invite:', event);
        // TODO: Handle incoming WebRTC calls
      }
    });

    // Start the Matrix client
    await this.matrixClient.startClient();
    
    console.log('Matrix client started successfully');
  }

  async shutdown(): Promise<void> {
    console.log('Shutting down Matrix plugin...');
    
    if (this.matrixClient) {
      this.matrixClient.stopClient();
    }
    
    if (this.server) {
      this.server.shutdown();
    }
    
    console.log('Matrix plugin shut down successfully');
  }
}

// Main entry point
async function main(): Promise<void> {
  const plugin = new MatrixCallPlugin();
  
  // Handle graceful shutdown
  process.on('SIGINT', async () => {
    console.log('Received SIGINT, shutting down...');
    await plugin.shutdown();
    process.exit(0);
  });

  process.on('SIGTERM', async () => {
    console.log('Received SIGTERM, shutting down...');
    await plugin.shutdown();
    process.exit(0);
  });

  try {
    await plugin.initialize();
  } catch (error) {
    console.error('Failed to start Matrix plugin:', error);
    process.exit(1);
  }
}

// Start the plugin if this file is run directly
if (require.main === module) {
  main().catch((error) => {
    console.error('Fatal error in Matrix plugin:', error);
    process.exit(1);
  });
}

export { MatrixCallPlugin };